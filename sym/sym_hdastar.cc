#include "sym_hdastar.h"

#include "sym_ph.h" 
#include "sym_exploration.h"
#include "sym_bdexp.h"
#include "sym_hnode.h" 
#include "../debug.h"
#include "../option_parser.h"
#include "../plugin.h"

#include <mpi.h>

#define MPI_MSG_NODE 0 // node
#define MPI_MSG_INCM 1 // for updating incumbent. message is unsigned int.
#define MPI_MSG_TERM 2 // for termination.message is empty.
#define MPI_MSG_FTERM 3 // broadcast this message when process terminated.
#define MPI_MSG_P_INCM 4
#define MPI_MSG_PLAN 5 // plan construction
#define MPI_MSG_PLAN_TERM 6 // plan construction

SymHDAStar::SymHDAStar(const Options &opts) :
		SymEngine(opts), t_orig(opts.get<double>("t_orig")), currentPH(0), id(
				-1), world_size(-1), incumbent(numeric_limits<int>::max()) {
	printf("SymHDAStar::SymHDAStar\n");
	mpi_initialize(opts);
}

void SymHDAStar::initialize() {
	print_options();
	SymEngine::initialize();

	// Initialize hash function
	SymExploration* search = originalSearch->getFw();
	search->init_hashfunction(world_size);
}

// TODO: Parallelize this one!
int SymHDAStar::step() {
	probe();
	SymExploration * currentSearch = selectExploration();
	if (currentSearch) {
		currentSearch->stepImage();
		if (!currentSearch->isAbstracted()) {
			for (auto ph : phs) {
				ph->operate(originalSearch);
			}
		}
	}
//	parition(currentSearch);
	send();
	return stepReturn();
}

int SymHDAStar::probe() {
	printf("SymHDAStar::probe()\n");
	MPI_Status status;
	int has_received = 0;

	if (do_probe()) {

		MPI_Iprobe(MPI_ANY_SOURCE, MPI_MSG_NODE, MPI_COMM_WORLD, &has_received,
				&status);
		while (has_received) {
			int d_size = 0;
			int source = status.MPI_SOURCE;
			MPI_Get_count(&status, MPI_CHAR, &d_size); // TODO: = node_size?

			// TODO: this buffer does not need to be allocated every time.
			//       put it as a static vector?
			char *d = new char[d_size];
			MPI_Recv(d, d_size, MPI_CHAR, source, MPI_MSG_NODE, MPI_COMM_WORLD,
			MPI_STATUS_IGNORE);

			std::vector<char> dvector();

			std::string fname("iprobe_tmp_" + std::to_string(id));
			std::ofstream out(fname, ios::binary);
			out.write((char*) d, d_size);

//			std::string orig("partition_1_0_" + std::to_string(id));
//			BDD readerorig = originalSearch->getManager()->mgr()->read_file(orig);
//			printf("orig: %d\n", readerorig.nodeCount());

			BDD reader = originalSearch->getManager()->mgr()->read_file(fname);
			printf("sent: %d\n", reader.nodeCount());

			delete[] d;

			has_received = 0;
			MPI_Iprobe(MPI_ANY_SOURCE, MPI_MSG_NODE, MPI_COMM_WORLD,
					&has_received, &status);
		}

	}
	return 0;
}

int SymHDAStar::send() {
	printf("SymHDAStar::send()\n");
	// 1. Retrieve messages which generated by search.
	SymExploration* orig = originalSearch->getFw();
	for (int i = 0; i < world_size; ++i) {
		std::vector<char> message = orig->get_message_buffer(i);
		MPI_Bsend(message.data(), message.size(), MPI_CHAR, i,
		MPI_MSG_NODE, MPI_COMM_WORLD);
	}

	// If found goal then send Incumbent solution.
	// If no job then send Termination detection.

	return 0;

}

bool SymHDAStar::do_probe() {
	return true; // For now disable those kind of optimizations.
	probe_counter++;
	if (probe_counter % probe_threshold == 0) {
		probe_counter = 0;
		return true;
	} else {
		return false;
	}
}

// Partition the image to distribute among processes.
int SymHDAStar::parition(SymExploration* search) {

	return 0;
}

int SymHDAStar::mpi_initialize(const Options &opts) {
	printf("SymHDAStar::mpi_initialize()\n");
//	if (opts.contains("distribution")) {
//		printf("SELECTED DISTRIBUTION HASH\n");
//		hash = opts.get<DistributionHash*>("distribution");
//	} else {
//		printf("DEFAULT HASH\n");
//		hash = new ZobristHash(opts);
//	}
//	hash = new ZobristHash(opts);

	node_sent = 0;
	msg_sent = 0;
	term_msg_sent = 0;
	termination_counter = 0;

	///////////////////////////////
	// MPI related initialization
	///////////////////////////////
	// 1. initialize MPI
	// 2. set id, number of the nodes
	int initialized;
	MPI_Initialized(&initialized);
	if (!initialized) {
		MPI_Init(NULL, NULL);
	}

	MPI_Comm_size(MPI_COMM_WORLD, &world_size);
	MPI_Comm_rank(MPI_COMM_WORLD, &id);
	printf("%d/%d processes\n", id, world_size);
	outgo_buffer.resize(world_size);

	has_sent_first_term = false;
	income_counter = 0;
	incumbent_counter = 0;

	// State id and its cost
	incumbent = numeric_limits<int>::max();
	incumbent_goal_state = pair<unsigned int, int>(0,
			numeric_limits<int>::max());

	unsigned int buffer_size = 400000000; // TODO: PARAMETER

	mpi_buffer = new unsigned char[buffer_size];
	fill(mpi_buffer, mpi_buffer + buffer_size, 0);
	MPI_Buffer_attach((void *) mpi_buffer, buffer_size);

	probe_threshold = 5;
	probe_counter = 0;


	MPI_Barrier(MPI_COMM_WORLD);

	return 0;

}

// TODO: For now we care about forward search only.
//       Improving abstraction is difficult in distributed environment, so let's walk aside of that. for now.
SymExploration * SymHDAStar::selectExploration() {
	return originalSearch->getFw();
}

void SymHDAStar::print_options() const {
	cout << "SymHDAStar* " << endl;
	cout << "   Search dir: " << searchDir << cout << endl;
	cout << "   Time force original: " << t_orig << " seconds" << endl;
}

static SearchEngine *_parse_symhdastar(OptionParser &parser) {
	SymEngine::add_options_to_parser(parser);
	parser.add_option<double>("t_orig",
			"After t_orig seconds, only search on the original state space.",
			"1500.0");
	parser.add_option<DistributionHash *>("distribution",
			"distribution function for hdastar", "zobrist");
	Options opts = parser.parse();

	SearchEngine *policy = 0;
	if (!parser.dry_run()) {
		policy = new SymHDAStar(opts);
	}
	return policy;
}

//SymExploration * SymHDAStar::selectExploration() {
//	if (forceOriginal()) {
//		// We are forced to search in the original state space because no
//		// more time should be spent on abstractions
//		return originalSearch->selectBestDirection(true);
//	}
//
//	//I cannot explore the original state space. I must select a
//	// relaxed search that is useful and explorable.
//	vector<SymExploration *> potentialExplorations;
//	potentialExplorations.push_back(originalSearch->getFw());
//	potentialExplorations.push_back(originalSearch->getBw());
//	originalSearch->getFw()->getPossiblyUsefulExplorations(
//			potentialExplorations);
//	originalSearch->getBw()->getPossiblyUsefulExplorations(
//			potentialExplorations);
//
//	//1) Look in already generated explorations => get the easiest one
//	//(gives preference to shouldSearch abstractions)
//	std::sort(begin(potentialExplorations), end(potentialExplorations),
//			[this] (const SymExploration * e1, const SymExploration * e2) {
//				return e1->isBetter (*e2);
//			});
//	for (auto exp : potentialExplorations) {
//		if (exp->isSearchable() && exp->isUseful()) {
//			return exp;
//		}
//	}
//
//	//2) Select a hierarchy policy and generate a new exploration
//	// for(SymExploration * exp : potentialExplorations){
//	//   //Check if it is useful (because if the other direction was deemed
//	//   //as no useful), then we should not try to relax it again
//	//   if(!exp->isAbstracted() || !exp->getBDExp()->isRelaxable() || !exp->isUseful()) continue;
//
//	//   SymBDExp * newBDExp = exp->getBDExp()->relax();
//	//   if(newBDExp){
//	//     if(newBDExp->isSearchable()){
//	// 	DEBUG_MSG(cout << "Select best direction of: " << *newBDExp << endl;);
//	// 	return newBDExp->selectBestDirection();
//	//     }else{
//	// 	//Add explicit heuristic
//	//     }
//	//   }
//	// }
//
//	//3) Ask hierarchy policies to generate new heuristics/explorations
//	for (int i = 0; i < phs.size(); i++) { //Once per heuristic
//		bool didSomething = phs[currentPH]->askHeuristic(originalSearch,
//				t_orig - g_timer());
//		currentPH++;
//		if (currentPH >= phs.size()) {
//			currentPH = 0;
//		}
//		if (didSomething)
//			return nullptr;
//	}
//
//	//4) We cannot search anything, just keep trying original search
//	//Â¿continue easiest instead?
//	return originalSearch->selectBestDirection(true);
//}

static Plugin<SearchEngine> _plugin_symhdastar("symhdastar", _parse_symhdastar);
