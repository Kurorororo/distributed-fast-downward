#include "sym_hdastar.h"

#include "sym_ph.h" 
#include "sym_exploration.h"
#include "sym_bdexp.h"
#include "sym_hnode.h" 
#include "../debug.h"
#include "../option_parser.h"
#include "../plugin.h"
#include "../cudd-2.5.0/include/dddmp.h"

#include <mpi.h>

#define MPI_MSG_NODE 0 // node
#define MPI_MSG_INCM 1 // for updating incumbent. message is unsigned int.
#define MPI_MSG_TERM 2 // for termination.message is empty.
#define MPI_MSG_FTERM 3 // broadcast this message when process terminated.
#define MPI_MSG_P_INCM 4
#define MPI_MSG_PLAN 5 // plan construction
#define MPI_MSG_PLAN_TERM 6 // plan construction

SymHDAStar::SymHDAStar(const Options &opts) :
		SymEngine(opts), t_orig(opts.get<double>("t_orig")), currentPH(0), id(
				-1), world_size(-1), incumbent(numeric_limits<int>::max()) {
	printf("SymHDAStar::SymHDAStar\n");
	mpi_initialize(opts);
}

void SymHDAStar::initialize() {
	printf("SymHDAStar::initialize()\n");
	print_options();
	SymEngine::initialize();

	// Initialize hash function
	SymExploration* search = originalSearch->getFw();
	search->init_hashfunction(world_size);
}

// TODO: Parallelize this one!
int SymHDAStar::step() {
	probe();
	SymExploration * currentSearch = selectExploration();
	if (currentSearch) {
		currentSearch->stepImage();
		if (!currentSearch->isAbstracted()) {
			for (auto ph : phs) {
				ph->operate(originalSearch);
			}
		}
	}
//	parition(currentSearch);
	send();

	// TODO: stepReturn: how do we deal with this?
	// 	1. If solution is found, then broadcast it!
	// 	2. If no work, then initiate termination detection!
	return stepReturn();
}

int SymHDAStar::stepReturn() const {
	if (!solved()) {
		return IN_PROGRESS;
	} else {
		if (terminate_detection()) {
			if (found_solution()) {
				return SOLVED;
			} else {
				return FAILED;
			}
		} else {
			return IN_PROGRESS;
		}
	}
}

int SymHDAStar::probe() {
	printf("SymHDAStar::probe()\n");
	MPI_Status status;
	int has_received = 0;

	if (do_probe()) {

		MPI_Iprobe(MPI_ANY_SOURCE, MPI_MSG_NODE, MPI_COMM_WORLD, &has_received,
				&status);
		while (has_received) {
			printf("Received BDD!\n");
			BDD received = receive_bdd(status);
			put_in_open(received);
			has_received = 0;
			MPI_Iprobe(MPI_ANY_SOURCE, MPI_MSG_NODE, MPI_COMM_WORLD,
					&has_received, &status);
		}

	}
	return 0;
}

BDD SymHDAStar::receive_bdd(MPI_Status& status) {
	int d_size = 0;
	int source = status.MPI_SOURCE;
	MPI_Get_count(&status, MPI_CHAR, &d_size); // TODO: = node_size?

	std::vector<char> dvector(d_size);

	MPI_Recv(&dvector.front(), dvector.size(), MPI_CHAR, source, MPI_MSG_NODE,
	MPI_COMM_WORLD,
	MPI_STATUS_IGNORE);
	printf("dvector: %s\n", dvector.data());

	FILE* file = fmemopen(dvector.data(), d_size, "r+");

	Cudd* mgr = originalSearch->getManager()->mgr();

//	char char_filename[] = "receive";
	DdNode* result = Dddmp_cuddBddLoad(mgr->getManager(), //DdManager * ddMgr, IN: DD Manager
			DDDMP_VAR_MATCHIDS, //Dddmp_VarMatchType  varMatchMode, IN: storing mode selector
			NULL, //char ** varmatchnames, IN: array of variable names - by IDs
			NULL, //int * varmatchauxids, IN: array of variable auxids - by IDs
			NULL, //int * varcomposeids, IN: array of new ids accessed - by IDs
			DDDMP_MODE_DEFAULT, //int  mode, IN: requested input file format
			NULL, //char * file, IN: file name
			file); //FILE * fp IN: file pointer

	BDD g(*mgr, result);
	return g;
}

// Put received BDD into local open list.
void SymHDAStar::put_in_open(BDD msg) {
	printf("receive nodes = %d\n", msg.nodeCount());

}

int SymHDAStar::send() {
	printf("SymHDAStar::send()\n");
	// 1. Retrieve messages which generated by search.
	SymExploration* orig = originalSearch->getFw();
	for (int i = 0; i < world_size; ++i) {
		if (i != id) {
			send_bdd(orig->get_message_buffer(i), i);
		}
	}

	// If found goal then send Incumbent solution.
	// If no job then send Termination detection.

	return 0;

}

int SymHDAStar::send_bdd(BDD bdd, int dist) {
//	string filename = "send" + to_string(id) + "_" + to_string(dist);
//	cout << "Writting BDD on " << filename << endl;
//	char * char_filename = strdup(filename.c_str());

	vector<char> sendData(100000); // TODO: What if file is bigger than 10000 chars?
	FILE* file = fmemopen(sendData.data(), sendData.size(), "w+");

	Dddmp_cuddBddStore(bdd.manager(), // DdManager * ddMgr, IN: DD Manager
			NULL, //  char * ddname, IN: DD name (or NULL)
			bdd.getNode(), //  DdNode * f, IN: BDD root to be stored
			NULL, //  char ** varnames, IN: array of variable names (or NULL)
			NULL, //  int * auxids, IN: array of converted var ids
			DDDMP_MODE_DEFAULT, //  int  mode, IN: storing mode selector
			DDDMP_VARIDS, //  Dddmp_VarInfoType  varinfo, IN: extra info for variables in text mode
			NULL, //  char * fname, IN: File name
			file); //  FILE * fp IN: File pointer to the store file
//	free(char_filename);

	fseek(file, 0, SEEK_END);
	int sendDataSize = ftell(file); // Get the file length

	MPI_Bsend(sendData.data(), sendDataSize, MPI_CHAR, MPI_MSG_NODE, dist,
	MPI_COMM_WORLD);
	fclose(file);

	return 0;
}

bool SymHDAStar::do_probe() {
	return true; // For now disable those kind of optimizations.
	probe_counter++;
	if (probe_counter % probe_threshold == 0) {
		probe_counter = 0;
		return true;
	} else {
		return false;
	}
}

// Partition the image to distribute among processes.
int SymHDAStar::parition(SymExploration* search) {

	return 0;
}

int SymHDAStar::mpi_initialize(const Options &opts) {
	printf("SymHDAStar::mpi_initialize()\n");
//	if (opts.contains("distribution")) {
//		printf("SELECTED DISTRIBUTION HASH\n");
//		hash = opts.get<DistributionHash*>("distribution");
//	} else {
//		printf("DEFAULT HASH\n");
//		hash = new ZobristHash(opts);
//	}
//	hash = new ZobristHash(opts);

	node_sent = 0;
	msg_sent = 0;
	term_msg_sent = 0;
	termination_counter = 0;

	///////////////////////////////
	// MPI related initialization
	///////////////////////////////
	// 1. initialize MPI
	// 2. set id, number of the nodes
	int initialized;
	MPI_Initialized(&initialized);
	if (!initialized) {
		MPI_Init(NULL, NULL);
	}

	MPI_Comm_size(MPI_COMM_WORLD, &world_size);
	MPI_Comm_rank(MPI_COMM_WORLD, &id);
	printf("%d/%d processes\n", id, world_size);
	outgo_buffer.resize(world_size);

	has_sent_first_term = false;
	income_counter = 0;
	incumbent_counter = 0;

	// State id and its cost
	incumbent = numeric_limits<int>::max();
	incumbent_goal_state = pair<unsigned int, int>(0,
			numeric_limits<int>::max());

	unsigned int buffer_size = 400000000; // TODO: PARAMETER

	mpi_buffer = new unsigned char[buffer_size];
	fill(mpi_buffer, mpi_buffer + buffer_size, 0);
	MPI_Buffer_attach((void *) mpi_buffer, buffer_size);

	probe_threshold = 5;
	probe_counter = 0;

	MPI_Barrier(MPI_COMM_WORLD);

	return 0;

}

int SymHDAStar::terminate_detection() const {
	MPI_Status status;
	int has_received = 0;


	MPI_Iprobe(MPI_ANY_SOURCE, MPI_MSG_FTERM, MPI_COMM_WORLD, &has_received,
			MPI_STATUS_IGNORE);
	if (has_received) {
		printf("received fterm\n");
		return true;
	}

	has_received = 0;
	MPI_Iprobe((id + world_size - 1) % world_size, MPI_MSG_TERM, MPI_COMM_WORLD,
			&has_received, &status);
	if (has_received) {


		unsigned char term = 0;
		unsigned char term2 = 0;
		MPI_Recv(&term, 1, MPI_BYTE, (id + world_size - 1) % world_size,
		MPI_MSG_TERM, MPI_COMM_WORLD, MPI_STATUS_IGNORE);

		has_received = 0;

		MPI_Iprobe((id + world_size - 1) % world_size, MPI_MSG_TERM,
				MPI_COMM_WORLD, &has_received, &status);

		// This while loop is here to flush all messages
		while (has_received) {
			MPI_Recv(&term2, 1, MPI_BYTE, (id + world_size - 1) % world_size,
			MPI_MSG_TERM, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
			term = (term > term2 ? term : term2);
			has_received = 0;
			MPI_Iprobe((id + world_size - 1) % world_size, MPI_MSG_TERM,
					MPI_COMM_WORLD, &has_received, &status);
		}

		if (term > 2) {
			MPI_Bsend(&term, 1, MPI_BYTE, (id + 1) % world_size, MPI_MSG_TERM,
					MPI_COMM_WORLD);
			return true;
		}

		// here term is the received message.
		// if term == terminate_count ->     send increment
		// if term >  terminate_count + 1 -> send terminate_count
		// if term <  terminate_count ->     send term

		if (term > termination_counter + 1) {
			term = termination_counter + 1;
		}

		termination_counter = term;

		if (id == 0) {
			++term;
		}

		++term_msg_sent;
		MPI_Bsend(&term, 1, MPI_BYTE, (id + 1) % world_size, MPI_MSG_TERM,
				MPI_COMM_WORLD);
		if (term > 2) {
			return true;
		}
	} else {
//		printf("%d received no term messages\n", id);
//		termination_counter = 0;
	}
//	if (id == 0) {
//		printf("cc%d\n", 424);
//	}

	if (id == 0 && !has_sent_first_term) {
//	if (id == 0) {
		if (income_counter >= 100) {
//		printf("%d termination detection\n", id);
			unsigned char term = 1;
			MPI_Bsend(&term, 1, MPI_BYTE, (id + 1) % world_size, MPI_MSG_TERM,
					MPI_COMM_WORLD);
//		printf("sent first term %d to %d\n", term, (id + 1) % world_size);
			has_sent_first_term = true;
			income_counter = 0;
			++term_msg_sent;
		} else {
		}
		++income_counter;
//		sleep(2);
	}

	return false;
}


// TODO: For now we care about forward search only.
//       Improving abstraction is difficult in distributed environment, so let's walk aside of that. for now.
SymExploration * SymHDAStar::selectExploration() {
	return originalSearch->getFw();
}

void SymHDAStar::print_options() const {
	cout << "SymHDAStar* " << endl;
	cout << "   Search dir: " << searchDir << cout << endl;
	cout << "   Time force original: " << t_orig << " seconds" << endl;
}

static SearchEngine *_parse_symhdastar(OptionParser &parser) {
	SymEngine::add_options_to_parser(parser);
	parser.add_option<double>("t_orig",
			"After t_orig seconds, only search on the original state space.",
			"1500.0");
	parser.add_option<DistributionHash *>("distribution",
			"distribution function for hdastar", "zobrist");
	Options opts = parser.parse();

	SearchEngine *policy = 0;
	if (!parser.dry_run()) {
		policy = new SymHDAStar(opts);
	}
	return policy;
}

//SymExploration * SymHDAStar::selectExploration() {
//	if (forceOriginal()) {
//		// We are forced to search in the original state space because no
//		// more time should be spent on abstractions
//		return originalSearch->selectBestDirection(true);
//	}
//
//	//I cannot explore the original state space. I must select a
//	// relaxed search that is useful and explorable.
//	vector<SymExploration *> potentialExplorations;
//	potentialExplorations.push_back(originalSearch->getFw());
//	potentialExplorations.push_back(originalSearch->getBw());
//	originalSearch->getFw()->getPossiblyUsefulExplorations(
//			potentialExplorations);
//	originalSearch->getBw()->getPossiblyUsefulExplorations(
//			potentialExplorations);
//
//	//1) Look in already generated explorations => get the easiest one
//	//(gives preference to shouldSearch abstractions)
//	std::sort(begin(potentialExplorations), end(potentialExplorations),
//			[this] (const SymExploration * e1, const SymExploration * e2) {
//				return e1->isBetter (*e2);
//			});
//	for (auto exp : potentialExplorations) {
//		if (exp->isSearchable() && exp->isUseful()) {
//			return exp;
//		}
//	}
//
//	//2) Select a hierarchy policy and generate a new exploration
//	// for(SymExploration * exp : potentialExplorations){
//	//   //Check if it is useful (because if the other direction was deemed
//	//   //as no useful), then we should not try to relax it again
//	//   if(!exp->isAbstracted() || !exp->getBDExp()->isRelaxable() || !exp->isUseful()) continue;
//
//	//   SymBDExp * newBDExp = exp->getBDExp()->relax();
//	//   if(newBDExp){
//	//     if(newBDExp->isSearchable()){
//	// 	DEBUG_MSG(cout << "Select best direction of: " << *newBDExp << endl;);
//	// 	return newBDExp->selectBestDirection();
//	//     }else{
//	// 	//Add explicit heuristic
//	//     }
//	//   }
//	// }
//
//	//3) Ask hierarchy policies to generate new heuristics/explorations
//	for (int i = 0; i < phs.size(); i++) { //Once per heuristic
//		bool didSomething = phs[currentPH]->askHeuristic(originalSearch,
//				t_orig - g_timer());
//		currentPH++;
//		if (currentPH >= phs.size()) {
//			currentPH = 0;
//		}
//		if (didSomething)
//			return nullptr;
//	}
//
//	//4) We cannot search anything, just keep trying original search
//	//¿continue easiest instead?
//	return originalSearch->selectBestDirection(true);
//}

static Plugin<SearchEngine> _plugin_symhdastar("symhdastar", _parse_symhdastar);
